package engine{	import flash.events.Event;	import flash.events.KeyboardEvent;	import flash.display.MovieClip;	import flash.ui.Keyboard;	import engine.Scoreboard;	import engine.Screen;	import engine.IKeyboard;	import engine.actors.Actor;    import engine.actors.player.Hero;    import engine.actors.DialogBox;    import engine.actors.weapons.Weapon;    import engine.actors.enemies.Enemy;    import engine.Scoreboard;    import engine.actors.geoms.*;    import engine.actors.specials.*;    	dynamic public class Map extends Screen implements IKeyboard {			    	    public var myName = "jerkface";		public var observerArray:Array = new Array(); // this is the array of observers on the map		public var subjectArray:Array = new Array(); // this is the array of subjects on the map				public var subjectArrayPrev:Array = new Array(); // this is a memory area for previous subject arrays,		                                                 // in the case of dialog boxes, boss fight triggers,		                                                 // and things of that nature				protected var screenPadding:Number = 128; // the number of pixels near the edge before the screen begins panning		protected var screenWidth:Number = 256; // how wide is our viewport		protected var screenHeight:Number = 208; // how high is our viewport				protected var mapWidth:Number = 0;				protected var myHero:Hero; // local variable for our player				protected var keyMaster; // holding variable for our keyboard controller		protected var prevKeyMaster; // holding var for previous keyboard master		protected var newKeyMaster; // holder for new keymaster			    protected var scoreboard:Scoreboard = Scoreboard.getInstance(); // grab an instance of our scoreboard        protected var heroHP:Number; // current HP of the hero, this is sorta convoluted				public function Map():void {			if (stage != null) {				setup();			} else {				addEventListener(Event.ADDED_TO_STAGE, addedToStage);			}		}		        public function getHero() {            if(myHero != null) {                return myHero;            } else {                return false;            }        }				private function addedToStage(evt):void {			removeEventListener(Event.ADDED_TO_STAGE, addedToStage);			setup();		}				private function setup() {		    mapWidth = this.width;		    buildMap();		}				public function updateSubscriptions():void {		    for(var p=0; p<this.numChildren; p++) { // for all the map's children		        var myChild = this.getChildAt(p);   // get them into a variable		        if(myHero is Hero && myChild is Actor) { // if we've already got our hero defined, and we're looking at an actor					if(myChild.alwaysOn) { // if we've got a special case actor that's gotta be always on						registerActor(myChild); // register them regardless of their range to the hero					} else if(Math.abs(myHero.x - myChild.x) < screenWidth || myChild is Geom) { // if they're within a certain range of the hero, or a geom    	                registerActor(myChild); // register them    		        } else { // or if they aren't in a certain range or a geom    		            deregisterActor(myChild); // deregister them    		        }		        } else if(myChild is Hero) { // otherwise, if we don't have a hero, and this is a hero		            registerActor(myChild); // register our hero		            changeFocus(myChild); // give the hero keyboard control		            myHero = myChild; // and set him officially as our hero		        }		    }		}				public function buildMap():void {		    // loop through all the child objects attached to this library item, and put		    // references to them into appropriate local arrays.  Afterwards, we'll subscribe		    // them to each other, and to the map itself		    heroHP = scoreboard.getHeroHP();		    var myChild;    		for(var p=0; p<this.numChildren; p++) { // for all the map's children		        myChild = this.getChildAt(p);   // get them into a variable		        registerSubject(myChild);		    }		    for(var q=0; q<this.numChildren; q++) { // for all the map's children		        myChild = this.getChildAt(q);   // get them into a variable		        registerObserver(myChild);		    }    		updateSubscriptions();    		updateStatus(ACTIVE);    		prevStatus = ACTIVE;			notifyObservers(); // tell our observers that we've completed our load out		}				private function pauseMap():void {	        subjectArrayPrev = subjectArray; // store our current subject array into our placeholder		    for(var i:int=0; i<subjectArray.length; i++) { // go through all our subjects		        unsubscribeAllFrom(subjectArray[i]); // and unsubscribe our observers from them		    }		    subjectArray = new Array(); // get rid of all subjects		    if(keyMaster is Hero) { // if the keymaster is our hero		    		    } else { // otherwise		        subjectArray.push(keyMaster); // make the new keymaster our only subject		    }		}				public function unPauseMap(actor):void {		    subjectArray = subjectArrayPrev; // restore our subject array to its former glory		    for(var i:int=0; i<subjectArray.length; i++) { // go through all our subjects		        subscribeAllTo(subjectArray[i]); // and subscribe all our observers to them		    }		    if(actor is DialogBox) { // if there's a dialog box		        removeChild(actor); // remove it from the map		    }		    updateStatus(ACTIVE); // and reset us to active		}				public function spawnActor(actor:Actor, x = 0, y = 0) {		    addChild(actor); // add our actor to the stage, it'll get registered in the next loop		    actor.x = x; // set its x coord		    actor.y = y; // and its y coord		}				private function unsubscribeAllFrom(actor) {		    for(var q:int=0; q<observerArray.length; q++) { // and then loop through all our observers                actor.removeObserver(observerArray[q]); // and unsubscribe them from our actor              }		}				private function subscribeAllTo(actor) {		    for(var q:int=0; q<observerArray.length; q++) {		        actor.addObserver(observerArray[q]);		    }		}				private function changeFocus(actor) {		    if(!keyMaster) { // if we've never had a keymaster		        keyMaster = actor; // make this guy the keymaster		        stage.addEventListener(KeyboardEvent.KEY_DOWN, actor.keyDownHandler); // and subscribe him to the keyboard		        stage.addEventListener(KeyboardEvent.KEY_UP, actor.keyUpHandler); // in both its forms		    } else if(actor != keyMaster) { // otehrwise, if we have a new keymaster		        if(actor is IKeyboard) { // and he's qualified to handle keyboard inputs		            stage.removeEventListener(KeyboardEvent.KEY_DOWN, actor.keyDownHandler); // unsubscribe from key down    		        stage.removeEventListener(KeyboardEvent.KEY_UP, actor.keyUpHandler); // and from key up    		        prevKeyMaster = keyMaster; // save our previous keyMaster    		        keyMaster = actor; // and annoint our new one    		        stage.addEventListener(KeyboardEvent.KEY_DOWN, actor.keyDownHandler); // and subscribe him to the keyboard    		        stage.addEventListener(KeyboardEvent.KEY_UP, actor.keyUpHandler); // in both its forms		        }		    }		}				public function getViewportCoords():Number {		    return(-this.x + 8);		}				private function registerSubject(actor) {		    		    if(actor is Actor) { // if our actor is an actor		        actor.setMap(this); // set ourselves as the actor's map		    }		    if(actor is Block || actor is Cloud || actor is KillBlock || actor is Door) { // if they're a virtual geom		    	actor.alpha = 0; // make them invisible		    }		    		    if(actor is DialogBox) {		        changeFocus(actor); // give our actor keyboard control		        updateStatus(PAUSING); // update our status to paused		        actor.setMap(this); // set our map ref on the thinger		        actor.typeText();		    } else if(actor is ISubject) { // if the actor is a subject 		        if(!subjectExists(actor)) { // and they haven't been registered yet    		        subjectArray.push(actor); // add them to our subjects array    		        actor.addObserver(this); // and subscribe the map to them    		    }		    }		}				private function registerObserver(actor) {		    if(actor is IObserver) { // if they're an observer		        if(!observerExists(actor)) { // and they're not in our observers list    		        observerArray.push(actor); // add them to it    		        for(var s=0; s<subjectArray.length; s++) { // and go through every subject on our map                        subjectArray[s].addObserver(actor);  // and subscribe our observer to them                    }    		    }		    }		}				private function registerActor(actor) {		    if(actor is DialogBox) {		        changeFocus(actor); // give our actor keyboard control		        updateStatus(PAUSING); // update our status to paused		        actor.setMap(this); // set our map ref on the thinger		        actor.typeText();		    } else {		        if(actor is ISubject) { // if the actor is a subject    		        if(!subjectExists(actor)) { // and they haven't been registered yet        		        subjectArray.push(actor); // add them to our subjects array        		        actor.addObserver(this); // and subscribe the map to them        		        subscribeAllTo(actor); // and subscribe all our observers to it        		    }    		    }    		    if(actor is IObserver) { // if they're an observer    		        if(!observerExists(actor)) { // and they're not in our observers list        		        observerArray.push(actor); // add them to it        		        for(var s=0; s<subjectArray.length; s++) { // and go through every subject on our map                            subjectArray[s].addObserver(actor);  // and subscribe our observer to them                        }        		    }    		    }    		    if(actor is Actor) { // if our actor is an actor    		        actor.setMap(this); // set ourselves as the actor's map    		    }    		    if(actor is Block || actor is Cloud || actor is KillBlock || actor is Door) { // if they're a virtual geom    		    	actor.alpha = 0; // make them invisible    		    }		    }		}				private function deregisterActor(actor) {		   if(actor is ISubject) { // if he's a subject		       for (var sb:int=0; sb<subjectArray.length; sb++) { // go through all of our subjects                   if(subjectArray[sb] == actor) { // and when you find the subject that's our subject                       unsubscribeAllFrom(actor); // get this off everythang                       subjectArray.splice(sb,1); // remove it from the array                   }               }		   }		   if(actor is IObserver) { // if he's an observer		       for (var ob:int=0; ob<observerArray.length; ob++) { // loop through all our observers                   if(observerArray[ob] == actor) { // and when you find the one that's him                       observerArray.splice (ob,1); // remove him from the array                       for(var k:int=0; k<subjectArray.length; k++) { // and loop through all our subjects                           subjectArray[k].removeObserver(actor); // and unsubscribe our observer from them                       }                   }               }		   }		   if(actor is Actor) {		       actor.setMap(this);   		   }		}				private function updateSubjects():void {		    for(var k:int=0; k<subjectArray.length; k++) {		        subjectArray[k].update();		    }		}				private function subjectExists(subject):Boolean {		    for(var i = 0; i < subjectArray.length; i++) {		        if(subject == subjectArray[i]) {		            return true;		        }		    }		    return false;		}				protected function moveMap(subject):void {	        var stageLeft = -this.x + screenPadding;		    var stageRight = -this.x + (screenWidth - screenPadding);		    if(subject.x < stageLeft) {		       this.x = -subject.x + screenPadding;		    } else if(subject.x > stageRight) {		        this.x = -subject.x + (screenWidth - screenPadding);		    }		    if(this.x < -mapWidth + (screenWidth)) {		        this.x = -mapWidth + (screenWidth);		    } else if(this.x > 0) {		        this.x = 0;		    }		    notifyObservers();		}				public function getHeroHP():Number {		    return heroHP;		}				override public function notify(subject:*):void {		    if(subject is Hero) {		        moveMap(subject);		        if(heroHP != scoreboard.getHeroHP()) { // if our hero's HP has changed		            heroHP = scoreboard.getHeroHP(); // reset our holder for HP		            notifyObservers(); // and tell the level about it		        }		    } else if(subject is Door) {		        updateStatus(COMPLETE); // if we hit the door, then we should move on		    }		}				public function removeFromMap(actor) {            deregisterActor(actor); // deregister the actor,    	    this.removeChild(actor); // and then remove them from the map			actor.isRemoved = true;    	}				private function observerExists(observer):Boolean { // check to see if we already have an observer on our list		    for(var ob:int=0; ob<observerArray.length; ob++) {		        if(observerArray[ob] == observer) {		            return true;		        }		    }		    return false;		}				public function customUpdate():void {		    // this will be replaced later            // by children of this class, should they            // require it		}				public function keyUpHandler(evt):void {		    // nothing here		}				public function keyDownHandler(evt):void {		    if(status == PAUSED) { // fix this someday		        if(evt.keyCode == Keyboard.ENTER) {		            unPauseMap(this);		        }		    } else if(status != PAUSING) {		        if(evt.keyCode == Keyboard.ENTER) {		            updateStatus(PAUSING);		        }		    }		}				override public function update(evt = null):Boolean {		    if(status == COMPLETE) {		        return false;		    } else if(status == HERO_DEAD) {		        return false;		    } else if(status == ACTIVE) {    		    customUpdate();    		    updateSubjects();    		    updateSubscriptions();    		    if(myHero.myStatus == 'DEAD') {    		        updateStatus(HERO_DEAD);    		    }    		} else if(status == PAUSED || status == PAUSING) { // if we're paused or pausing    		    if(status == PAUSING) {    		        pauseMap(); // pause the map    		        status = PAUSED; // and set our status    		    }		        customUpdate(); // keep doing our update scripts, but don't register/deregister actors		        updateSubjects(); // while paused		    }		    return true; // otherwise, sound the everything's ok alarm		}	}}