package engine.actors.player {        import utils.FlipTimer;	import flash.display.MovieClip;	import flash.events.*;	import flash.ui.Keyboard;	import engine.IKeyboard;	import flash.geom.Rectangle;	import flash.display.Bitmap;	import flash.display.BitmapData;	import flash.utils.ByteArray;	import flash.events.Event;	import engine.actors.Actor;	import engine.actors.Walker;	import engine.actors.geoms.*;	import engine.actors.specials.*;	import controls.KeyMap;	import engine.actors.weapons.Weapon;	import flash.media.Sound;	import flash.media.SoundChannel;	import engine.actors.enemies.EnemyChandelier;	import engine.actors.weapons.ActorCannon;	dynamic public class Hero extends Walker implements IKeyboard {	    	    // set our variables for different input        private static var BUTTON_DOWN = false;        private static var BUTTON_LEFT = false;        private static var BUTTON_RIGHT = false;        private static var BUTTON_SPACE = false;        private static var BUTTON_SHIFT = false;	    	    // these hold what things we can currently do	    private var shootEnabled = true;	    private var hatAvailable = true;			    public var hatThrown = false;	    private var skinSet = false;				private var keys:KeyMap = KeyMap.getInstance();								private var keyboardStatus:Array = new Array();		private var jumpSound = new hero_jump();		private var hurtSound = new hero_hurt();		private var powerupSound = new powerup_sound(); // this should be moved to the powerup, and renamed "scorePowerup"		private var healthPowerupSound = new martini_sound(); // this should be moved to the powerup		private var throwSound = new hero_throw(); // this should be moved to the hat		private var effectsChannel;				private var damageFlag = false; // flag for if the hero has been damaged		private var damageCounter = 0; // counter variable to see how long we've been damaged		private var damageDuration = 120; // number of frames to be invincible after damage				private var pauseCounter = 0;		private var get_gold_hat = new get_gold_hat_sound();		private var myActorCannon;				private var maxHP = 3; // max number of health point				protected var throwCounter = 0;		protected const throwDuration = 10;		protected var throwComplete = false;		public var pauseFlag = false;				// constructor, geesh		public function Hero():void {    			if (stage != null) {				buildHero();			} else {				addEventListener(Event.ADDED_TO_STAGE, addedToStage);			}		}				private function addedToStage(evt) {			buildHero();		}				private function buildHero():void{			//keys.addEventListener(KeyMap.KEY_UP, onKeyRelease);			myActorCannon = new ActorCannon();			myActorCannon.setOwner(this);			myMap.spawnActor(myActorCannon, this.x, this.y);			HP = scoreboard.getHeroHP();			setPowerupMode(scoreboard.getHeroPowerupMode());			Xspeed = 4;		}				private function setPowerupMode(newMode:String) {		    if(newMode != scoreboard.getHeroPowerupMode() || skinSet == false) {		        switch(newMode) {    		        case "GoldHatMode":    		            setSkin("HeroGoldHatSkin", tilesWide, tilesTall);    		            myActorCannon.setAmmoType("GoldHatProjectile");    		            myActorCannon.shotsMax = 1;    		            break;    		        default:    		            setSkin("HeroSkin", tilesWide, tilesTall);    		            myActorCannon.setAmmoType("HatProjectile");    		            myActorCannon.shotsMax = 1;    		            break;     		    }    		    setLoop(4, 1, 1, 1, 0, 2);    		    frameCounter = speed;    		    animate();    		    new FlipTimer(this, "loopOver", 200);    		    scoreboard.setHeroPowerupMode(newMode);    		    skinSet = true;		    }		}				public function loopOver() {		    pauseFlag = false;		    speed = 10;		    frameCount = speed;		    setAnimation(prevAction);		}				public function throwAnimationDone() {		    loopRowOffset = 0;		    frameCounter = speed;		    animate();		}				override public function update():void {		    if(scoreboard.getHeroHP()) { // if we're alive		        if(damageFlag) {  // if we're being damaged    		        if(damageCounter < damageDuration) { // flicker our alpha    		            this.alpha = damageCounter % 2; // every other frame    		            damageCounter++; // and count how long we've been damaged    		        } else { // if there's a damage flag, and duration is up    		            damageCounter = 0; // reset the damage counter    		            damageFlag = false; // and remove damage flag    		        }    		    }				if(this.y > 240) { // if we've fallen off the edge of the screen					killMe(); // we need to DIE				}								moveMe(); // move me around    		        		    readInput(); // and read the input for the next frame		    } else { // otherwise, if i have no HP                killMe(); // kill me		    }		}				public function keyDownHandler(evt):void {		    // here's where we handle keyboard changes		    if(evt.keyCode == Keyboard.SPACE) {		        BUTTON_SPACE = true;		    } else if(evt.keyCode == Keyboard.LEFT) {		        BUTTON_LEFT = true;		    } else if(evt.keyCode == Keyboard.RIGHT) {		        BUTTON_RIGHT = true;		    } else if(evt.keyCode == Keyboard.SHIFT) {		        BUTTON_SHIFT = true;		    }		}				public function keyUpHandler(evt):void {		    // here's where we handle keyboard changes		    if(evt.keyCode == Keyboard.SPACE) {		        BUTTON_SPACE = false;		        //if(vely < 0) { vely = Math.floor(vely * .5); }  // turn on mario-style jumping.  doesn't feel right		    } else if(evt.keyCode == Keyboard.LEFT) {		        BUTTON_LEFT = false;		    } else if(evt.keyCode == Keyboard.RIGHT) {		        BUTTON_RIGHT = false;		    } else if(evt.keyCode == Keyboard.SHIFT) {		        BUTTON_SHIFT = false;		    }		}				override public function setup() {		    collide_left = 8; // what pixel do we collide on on the left    		collide_right = 24; // what pixel do we collide on on the right		    		    myName = "Hero"; // the generic name of our enemy            mySkin = "HeroSkin"; // the name of the skin for this enemy		}					override public function receiveDamage(attacker):void {		    if(!damageFlag) {		        if(scoreboard.getHeroPowerupMode() != "Default") {		            setPowerupMode("Default");		        } else {		            HP -= attacker.damage;    		        scoreboard.setHeroHP(HP);		        }		        damageFlag = true;    		    effectsChannel = hurtSound.play(0);  // play it		    }		}				public function receivePowerup(powerup):void { // all this stuff should move to the powerups		    if(powerup is HealthPowerup) {		        HP += powerup.health;		        if(HP > maxHP) {		            HP = maxHP;		        }    		    scoreboard.setHeroHP(HP);    		    effectsChannel = healthPowerupSound.play(0);		    } else if(powerup is ScorePowerup) {				effectsChannel = powerupSound.play(0);  // play it			} else if(powerup is GoldHat) {			    setPowerupMode("GoldHatMode");			    effectsChannel = get_gold_hat.play(0); 			}		}				private function readInput():void {		    if(walkEnabled) {		        if(BUTTON_RIGHT) {		            this.velx += this.Xspeed;		            goingLeft = 0;		            if(this.velx > MAX_VEL_X) {		                this.velx = MAX_VEL_X;		            }		        } else if(BUTTON_LEFT) {		            this.velx -= this.Xspeed;					goingLeft = 1;					if(this.velx < -MAX_VEL_X) {					    this.velx = -MAX_VEL_X;					}		        }		    }		    		    if(jumpEnabled == true && jumpCount == 0 && jumpPressed == false) { // if we're allowed to jump	            if (BUTTON_SPACE) {					// -speed breaks the moving platform buffer s well as still platforms.					effectsChannel = jumpSound.play(0);  // play it, looping 100 times					this.y -= gravity;					this.vely = -jumpVelocity;					jumpCount++;					jumpPressed = true;				}	        }	        	        if(shootEnabled && hatAvailable) {	            if(BUTTON_SHIFT) {	                if(myActorCannon.shotAvailable) {	                   myActorCannon.fire();	                   BUTTON_SHIFT = false;       		           loopRowOffset = 2;       		           frameCounter = speed;       		           animate();       		           effectsChannel = throwSound.play()                       new FlipTimer(this, "throwAnimationDone", 250);                       	                }	            }	        }	        	        if(BUTTON_SPACE) {	            jumpPressed = true;	        } else {	            jumpPressed = false;	        }		}	    	    override public function notify(subject:*):void {			if(checkCollision(subject)) {		        subject.collide(this);		    }		}				override public function setAnimation(newAnimation) {		    if(!pauseFlag) {		        switch(newAnimation) {    		        case WALK:    		            setLoop(0, 1, 4, 1, 0, speed);    		            break;    		        case JUMP:    		            setLoop(4, 0, 0, 0, 0, speed);    		            break;    		        case STAND:    		            setLoop(0, 0, 0, 0, 0, speed);    		            break;    		        case FALL:    		            setLoop(4, 0, 0, 0, 0, speed);    		            break;    		        case DIE:    		            setLoop(8, 0, 0, 0, 0, speed);    		            break;    		    }    		    animate();		    }		}				override public function killMe():void {		    if(myStatus != 'DYING') { // if killMe's been issued, and i'm not yet dying		        setLoop(8, 0, 0, 0, 0, 5); // set my dying animation	            myStatus = 'DYING'; // set my status to dying	            this.vely = -6; // and begin my death jump	        }		    if(frameCount >= frameDelay) { // if we're good on framecount		        applyPhysics(); // apply physics for my fall		        this.y += vely; // move me		        animate(); // animate me		        if(this.y > 240) { // and if i'm off the screen		            myStatus = 'DEAD'; // i'm dead		        }		    } else { // otherwise		        frameCount++; // increase the framecount		    }		}			}}